### 1.9

plus(4, 5);를 평가할 때 각 함수가 생성하는 과정을 치환 모형으로 표현하라. 이 과정들은 반복적인가, 아니면 재귀적인가?

**재귀적**

```javascript
function plus(a, b) {
  return a === 0 ? b : inc(plus(dec(a), b));
}
```

plus(4,5)

inc(plus(3,5))

inc(inc(plus(2,5)))

inc(inc(inc(plus(1,5))))

inc(inc(inc(inc(plus(0,5)))))

inc(inc(inc(plus(5))))

inc(inc(plus(6)))

inc(plus(7))

inc(8)

9

**반복적**

```javascript
function plus(a, b) {
  return a === 0 ? b : plus(dec(a), inc(b));
}
```

plus(4,5)

plus(3,6)

plus(2,7)

plus(1,8)

plus(0,9)

9

### 1.10 (코드 돌려봄)

다음 함수는 애커만 함수(Ackermann’s function)라고 부르는 수학 함수를 계산한다.

```jsx
function A(x, y) { 
	return y === 0
	? 0
	: x === 0
	? 2 * y
	: y === 1
	? 2
	: A(x - 1, A(x, y - 1));
}
```

다음 문장들의 평가

```javascript
A(1, 10); // 1024
A(2, 4); // 65536
A(3, 3); // 65536
```

### 1.11

```javascript
function f(n) {
  return f_iter(2,1,0,n);
}

function f_iter(a,b,c,count) {
  return a === 2 && count < 3 ? count : count < 3 ? a : f_iter(a + 2 * b + 3 * c , a, b, count - 1);
} 
```

### 1.20

gcd(206, 40)의 평가로 생성되는 과정을 치환 모형( 정상 순서에 대한)을 이용하여 묘사하되, 실제로 수행된 remainder(%) 연산들을 표시해라.

gcd(206, 40)의 정상 순서 평가에서 remainder 연산이 실제로 몇 번이나 수행되는가? 적용적 순서 평가(인수 우선 평가)에서는 몇번인가?

- plus(4,5)

```javascript
function gcd(a, b) {
  return b === 0 ? a : gcd(b, a % b);
}
```

전개

gcd(206, 40)

- 40 === 0 ? 206 : gcd(40, 206 % 40)

gcd(40, 206 % 40)

- 206 % 40 === 0 ? 40 : gcd(206 % 40, 40 % (206 % 40)) **1**
    - 6 === 0 ? 40 : gcd(206 % 40, 40 % (206 % 40))

gcd(206 % 40 , 40 % (206 % 40))

- 40 % (206 % 40) === 0 ? 206 % 40 : gcd(40 % (206 % 40) , (206 % 40) % (40 % (206 % 40))) **2**
    - 4 === 0 ? 206 % 40 : gcd(40 % (206 % 40) , (206 % 40) % (40 % (206 % 40)))

gcd(40 % (206 % 40) , (206 % 40) % (40 % (206 % 40)))

- (206 **%** 40) % (40 **%** (206 % 40)) === 0 ? 40 % (206 % 40) ? gcd((206 % 40) % (40 % (206 % 40)) , (40 % (206 % 40)) % (206 % 40) % (40 % (206 % 40))) **4**
    - 2 === 0 ? 40 % (206 % 40) ? gcd((206 % 40) % (40 % (206 % 40)) , (40 % (206 % 40)) % (206 % 40) % (40 % (206 % 40)))

gcd((206 % 40) % (40 % (206 % 40)), (40 % (206 % 40)) % (206 % 40) % (40 % (206 % 40)))

- (40 **%** (206 % 40)) **%** (206 **%** 40) **%** (40 **%** (206 **%** 40)) === 0 ? (206 % 40) % (40 % (206 % 40)) : gcd((40 % (206 % 40)) % (206 % 40) % (40 % (206 % 40)), (206 % 40) % (40 % (206 % 40)) % (40 % (206 % 40)) % (206 % 40) % (40 % (206 % 40))) **7**
    - 0 === 0 ? (206 % 40) % (40 % (206 % 40)) : gcd((40 % (206 % 40)) % (206 % 40) % (40 % (206 % 40)), (206 % 40) % (40 % (206 % 40)) % (40 % (206 % 40)) % (206 % 40) % (40 % (206 % 40)))
- (206 **%** 40) **%** (40 % (206 % 40))  **4**

수행된 % 연산: 1 (술어) + 2 (술어) + 4 (술어) + 7 (술어) + 4(0 === 0에 맞는 연산) = **18**

축약

(206 % 40) % (40 % (206 % 40))

(206 % 40) % (40 % 6)

6 % 4

2



**인수 우선평가 (해석기가 해석하는 방식임. 함수와 인수 표현식을 먼저 평가하고 그 결과로 얻으 함수를 인수들에 적용한다.)**

gcd(206, 40)

- 40 === 0 ? 206 : gcd(40, 6)  ← 206 **%** 40을 우선 평가해서 인수로 집어넣음 **1**

gcd(40, 6)

- 6 === 0 ? 40 : gcd(6, 4) ← 40 **%** 6을 우선 평가해서 인수로 집어넣음 **1**

gcd(6, 4)

- 4 === 0 ? 6 : gcd(4, 2) ← 6 **%** 4를 우선 평가해서 인수로 집어넣음 **1**

gcd(4, 2)

- 2 === 0 ? 4 : gcd(2, 0) ← 4 **%** 2 우선평가 **1**

gcd(2, 0)

- 0 === 0 ? 2 : gcd(0, 0)

→ 2

수행된 % 연산 : 1 + 1 + 1 + 1 = **4**
